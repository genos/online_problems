<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>LOGLOG</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="LOGLOG"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-11-25T17:56-0500"/>
<meta name="author" content="Graham Enos"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012-2013  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>


<div id="content">
<h1 class="title">LOGLOG</h1>

<p>In <a href="http://algo.inria.fr/flajolet/Publications/DuFl03.pdf">this</a> paper, Marianne Durand and the late Phillipe Flajolet
describe an interesting algorithm that estimates the cardinality of
a large multiset&mdash;think the number of unique words in a
file&mdash;while using only a small amount of auxiliary memory to get
the job done. That is, an exact answer is easy to obtain
programmatically (use your favorite language's hashtable or set
making utilities, for instance), but if the multiset is large enough
the amount of memory required to store all the unique items may be
prohibitively large. Durand and Flajolet's technique uses much less
memory but provides an estimate instead of an exact answer, trading
off memory for precision.
</p>
<p>
The paper presupposes the existence of two functions:
</p><ul>
<li>a hash function h that maps elements from the domain of the multiset to
  bitstrings
</li>
<li>a function &rho; that returns the rank of the first 1-bit from the
  left in a given bitstring; i.e. &rho;(1&hellip;) = 0, &rho;(001&hellip;) = 2,
  etc.<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>
</li>
</ul>


<p>
Here is the basic algorithm from Durand &amp; Flajolet to estimate the
cardinality of a multiset <code>MS</code>.<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup> First, set m = 2<sup>k</sup> for some
bitsize k. Then,
</p>


<pre class="example">init array M[0:m-1] ← 0
for x = b_0,b_1... in MS:
    j ← int(b_0,b_1,...,b_{k-1})            // integer from the top k bits
    M[j] ← max(M[j], ρ(b_k,b_{k + 1},...))
return E = α_m * m * 2^(1 / m * sum(M))
</pre>

<p>
where &alpha;<sub>m</sub> is given by
\[ \left( \Gamma(-1/m) \frac{2^{1/m} - 1}{\ln 2} \right)^{-m} \]
and is used to "precisely correct the systematic bias in the
asymptotic limit."
</p>
<p>
This algorithm uses the hash function to map each element of <code>MS</code> to
an integer. From there, it uses the bit patterns of these elements to
sort each element into a bin in our array <code>M</code>. The idea is that the
top bits determine which bin to insert into, while the bottom bits
give the value to put into that bin. Rather than keep all of the
possible values a bin might receive, however, we only keep the
maximum; this gives a probabilistic measure of the number of items
inserted into any one bin.
</p>
<p>
Your task is to write an implementation of the LogLog algorithm
given above. When you are finished, you are welcome to read or run a
suggested solution, or to post your own solution or discuss the
exercise in the comments below.
</p>
<p>
<b>Page 2</b>
</p>
<p>
We'll write a straightforward Python (3.x series) implementation and
run it against the typical *nix installation's <code>/usr/share/dict/words</code>
as a benchmark.
</p>
<p>
We'll first begin with the auxiliary functions <code>alpha</code> and <code>rho</code>:
</p>


<pre class="example">from math import gamma, log
k = 16

def alpha(m):
    return pow(gamma(-1 / m) * (pow(2, 1 / m) - 1) / log(2), -m)

def rho(n):
    for i in range(k):
        if (n &amp; (1 &lt;&lt; (k - i))) != 0:
            return i
    return k
</pre>

<p>
The first function is just a straight translation of the math
version given in the paper, while <code>rho()</code> starts at the left-most
bit of its input and stops when it finds a one.
</p>
<p>
We also need a hash function; we'll use one built into Python,
modifying its output to return a 32 bit unsigned integer, but you can
just as easily use the hash function given in a <a href="http://programmingpraxis.com/2013/06/07/sets/">previous</a> exercise.
</p>



<pre class="example">def h(x):
    return hash(x) % (1 &lt;&lt; 32)
</pre>


<p>
Now that that's taken care of, we can write our <code>loglog</code> function:
</p>



<pre class="example">def loglog(MS):
    m = 1 &lt;&lt; k
    M = [0] * m
    for x in MS:
        i, j = divmod(h(x), m)
        M[j] = max(M[j], rho(i))
    return alpha(m) * m * pow(2, sum(M) / m)
</pre>


<p>
Here is our translation of the algorithm into code. We first set <code>m</code>
to be 2<sup>k</sup> and initialize our list <code>M</code> of zeros. Next, we walk through
our multiset. For each element therein, we use the top k bits to index
into our list <code>M</code>, and then set that value to the maximum of the
bottom k bits and the current value. Finally, we return our adjusted
estimate based on the sum of the values in <code>M</code>.
</p>
<p>
Here's our Python code to call this with the big text file:
</p>


<pre class="example">if __name__ == '__main__':
    with open('/usr/share/dict/words') as f:
        MS = [line.strip() for line in f]
    print(loglog(MS))
</pre>

<p>
Here are the results:
</p>


<pre class="example">$ python3 loglog.py
484992.2652755824
</pre>

<p>
Compare that to the result of running <code>wc</code> on the file (the main
reason we chose this as a test was that the number of words in the
file is small enough to count another way):
</p>


<pre class="example">$ wc -l /usr/share/dict/words
  479829
</pre>

<p>
Our LogLog estimate is just over 10% off of the actual; not bad,
considering that it will scale to larger datasets much more
effectively than the naive approach.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> Note that we begin counting from zero instead of 1; this is one
of the only things we'll do differently than the original paper.
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> The name of our multiset is the only other place we differ from
the original paper.
</p>



</div>
</div>
</div>

</body>
</html>
